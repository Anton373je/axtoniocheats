--[[ 
    366axtonio Script | v3.3 — Single-page categorized GUI + Kill Aura + ESP/Hitbox Scaling
    Modified: integrated a refined SAFE, developer-only Aim Assist that ONLY orients the camera
    (does NOT auto-shoot, does NOT modify other players' health, and is intended
    for local testing / single-player development only).

    Enhancements in this version (Aim Assist):
      - Much smoother, exponential smoothing so the camera doesn't "wobble"
      - Persistent lock on the nearest player's head (only switches when another player
        is significantly closer)
      - Always aims at head center and keeps tracking while target exists
      - Still DOES NOT fire or alter other players' state — developer-only tool

    Features:
        - WalkSpeed, JumpPower, SpeedBoost
        - Fly + FlySpeed, InfiniteJump, Noclip
        - ESP (Name + Box) + ESP Box Size Slider
        - AutoFarm
        - Teleport / Random Player / Player List
        - Rejoin, ServerHop, Destroy GUI
        - Gravity Slider, HipHeight Slider, FOV Slider
        - Sit Button, Reset Character Button
        - Server FPS Booster
        - Kill Aura (toggle + range)
        - Hitbox Size Slider
        - SAFE Aim Assist (dev-only): when enabled, camera smoothly follows the nearest head
          within range. DOES NOT shoot or change other players' health.
--]]

-- ========== Utility / Loader ==========
local ORION_URL = "https://raw.githubusercontent.com/shlexware/Orion/main/source"
local function detect_http_get()
    if pcall(function() return game.HttpGet end) and type(game.HttpGet)=="function" then
        return function(url) return game:HttpGet(url,true) end
    end
    if type(syn)=="table" and type(syn.request)=="function" then
        return function(url) local ok,r=pcall(function() return syn.request({Url=url,Method="GET"}) end) if ok and r then return r.Body end end
    end
    local http = http
    if type(http)=="table" and type(http.request)=="function" then
        return function(url) local ok,r=pcall(function() return http.request({Url=url,Method="GET"}) end) if ok and r then return r.Body end end
    end
    local HttpService = game:GetService("HttpService")
    if HttpService and type(HttpService.GetAsync)=="function" then
        return function(url) local ok,res=pcall(function() return HttpService:GetAsync(url) end) if ok then return res end end
    end
    return nil
end
local http_get = detect_http_get()
local loader = loadstring or (syn and syn.loadstring) or (KRNL and KRNL.loadstring) or (Fluxus and Fluxus.loadstring)

local OrionLib = nil
if loader and http_get then
    pcall(function()
        local src = http_get(ORION_URL)
        if type(src)=="string" and #src>50 then
            local chunk = loader(src)
            if type(chunk)=="function" then
                local ok, lib = pcall(chunk)
                if ok and type(lib)=="table" then OrionLib = lib end
            end
        end
    end)
end

-- ========== Shared services & state ==========
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TeleportService = game:GetService("TeleportService")
local Workspace = game:GetService("Workspace")

local State = {
    WalkSpeed = 16,
    JumpPower = 50,
    SpeedBoost = 1,
    Fly = false,
    FlySpeed = 60,
    InfiniteJump = false,
    Noclip = false,
    ESP = false,
    AutoFarm = false,
    FarmDelay = 0.5,
    Gravity = Workspace.Gravity,
    HipHeight = 2,
    FOV = 70,
    FPSBooster = false,
    KillAura = false,
    KillAuraRange = 10,
    ESPBoxSize = 1,
    HitboxScale = 1,
    -- SAFE Aim Assist (developer-only): only rotates camera toward nearest head, no shooting
    AimAssist = false,
    AimAssistRange = 80,
    AimAssistResponsiveness = 8 -- higher = snappier, lower = smoother
}

local function getHumanoidRoot(plr)
    if not plr then return nil end
    local char = plr.Character
    if not char then return nil end
    local hum = char:FindFirstChildOfClass("Humanoid")
    local root = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
    return hum, root
end

-- ========== ESP ==========
local ESPMap = {}
local function createESP(plr)
    if not plr or plr == LocalPlayer then return end
    if ESPMap[plr] and ESPMap[plr].Gui and ESPMap[plr].Gui.Parent then return end
    local hum, root = getHumanoidRoot(plr)
    if not root then return end

    local bb = Instance.new("BillboardGui")
    bb.Name = "AxtonioESP"
    bb.Adornee = root
    bb.Size = UDim2.new(0,140,0,40)
    bb.StudsOffset = Vector3.new(0,2.4,0)
    bb.AlwaysOnTop = true
    local label = Instance.new("TextLabel", bb)
    label.Size = UDim2.new(1,0,1,0)
    label.BackgroundTransparency = 1
    label.Text = plr.Name
    label.TextScaled = true
    label.Font = Enum.Font.GothamBold
    label.TextColor3 = Color3.fromRGB(255,100,100)
    bb.Parent = game.CoreGui

    local box = Instance.new("BoxHandleAdornment")
    box.Name = "ESPBox"
    box.Adornee = root
    box.Size = root.Size * (State.ESPBoxSize or 1)
    box.Color3 = Color3.fromRGB(255,100,100)
    box.AlwaysOnTop = true
    box.Transparency = 0.5
    box.Parent = root

    ESPMap[plr] = {Gui = bb, Box = box}
end

local function destroyAllESP()
    for p,info in pairs(ESPMap) do
        pcall(function() if info.Gui then info.Gui:Destroy() end end)
        pcall(function() if info.Box then info.Box:Destroy() end end)
    end
    ESPMap = {}
end

-- ESP aktualisieren, wenn Spieler respawnen
local function refreshESP(plr)
    if State.ESP then
        pcall(function()
            if ESPMap[plr] then
                if ESPMap[plr].Gui then ESPMap[plr].Gui:Destroy() end
                if ESPMap[plr].Box then ESPMap[plr].Box:Destroy() end
                ESPMap[plr]=nil
            end
            createESP(plr)
        end)
    end
end

Players.PlayerAdded:Connect(function(p)
    p.CharacterAdded:Connect(function() refreshESP(p) end)
end)
Players.PlayerRemoving:Connect(function(p)
    if ESPMap[p] then
        pcall(function() if ESPMap[p].Gui then ESPMap[p].Gui:Destroy() end end)
        pcall(function() if ESPMap[p].Box then ESPMap[p].Box:Destroy() end end)
        ESPMap[p]=nil
    end
end)

-- ========== AutoFarm ==========
spawn(function()
    while true do
        if State.AutoFarm then
            local plr = LocalPlayer
            if plr and plr:FindFirstChild("PlayerGui") then
                local btn = plr.PlayerGui:FindFirstChild("ClickButton", true) or plr.PlayerGui:FindFirstChildOfClass("RemoteEvent")
                if btn then
                    pcall(function()
                        if typeof(btn.FireServer) == "function" then btn:FireServer() end
                        if typeof(btn.Activate) == "function" then btn:Activate() end
                    end)
                end
            end
            wait(State.FarmDelay or 0.5)
        else
            wait(0.2)
        end
    end
end)

-- ========== Fly & Noclip & InfiniteJump ==========
local FlyBV_Name = "Axtonio_FlyBV"
local FlyBG_Name = "Axtonio_FlyBG"

local function enableFly(val)
    State.Fly = val
    local char = LocalPlayer and LocalPlayer.Character
    if not char then return end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end
    if val then
        if not root:FindFirstChild(FlyBV_Name) then
            local bv = Instance.new("BodyVelocity")
            bv.Name = FlyBV_Name
            bv.MaxForce = Vector3.new(1e5,1e5,1e5)
            bv.Parent = root
        end
        if not root:FindFirstChild(FlyBG_Name) then
            local bg = Instance.new("BodyGyro")
            bg.Name = FlyBG_Name
            bg.MaxTorque = Vector3.new(1e5,1e5,1e5)
            bg.Parent = root
        end
    else
        pcall(function() if root:FindFirstChild(FlyBV_Name) then root[FlyBV_Name]:Destroy() end end)
        pcall(function() if root:FindFirstChild(FlyBG_Name) then root[FlyBG_Name]:Destroy() end end)
    end
end

RunService.Heartbeat:Connect(function()
    if State.Fly and LocalPlayer and LocalPlayer.Character then
        local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if root and root:FindFirstChild(FlyBV_Name) then
            local bv = root[FlyBV_Name]
            local cam = workspace.CurrentCamera
            local move = Vector3.new(0,0,0)
            local forward = (UserInputService:IsKeyDown(Enum.KeyCode.W) and 1 or 0) - (UserInputService:IsKeyDown(Enum.KeyCode.S) and 1 or 0)
            local right = (UserInputService:IsKeyDown(Enum.KeyCode.D) and 1 or 0) - (UserInputService:IsKeyDown(Enum.KeyCode.A) and 1 or 0)
            local up = (UserInputService:IsKeyDown(Enum.KeyCode.E) and 1 or 0) - (UserInputService:IsKeyDown(Enum.KeyCode.Q) and 1 or 0)
            local camCFrame = cam and cam.CFrame or root.CFrame
            local dir = (camCFrame.LookVector * forward) + (camCFrame.RightVector * right) + Vector3.new(0, up, 0)
            if dir.Magnitude > 0 then
                move = dir.Unit * (State.FlySpeed or 60)
            end
            bv.Velocity = move
        end
    end

    if State.Noclip and LocalPlayer and LocalPlayer.Character then
        for _,part in pairs(LocalPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") and part.CanCollide == true and part.Name ~= "HumanoidRootPart" then
                pcall(function() part.CanCollide = false end)
            end
        end
    end

    -- Permanent Hitbox-Anpassung für LocalPlayer
    local char = LocalPlayer.Character
    if char then
        local root = char:FindFirstChild("HumanoidRootPart")
        if root then
            root.Size = Vector3.new(2,2,1) * (State.HitboxScale or 1)
        end
    end
end)

UserInputService.JumpRequest:Connect(function()
    if State.InfiniteJump then
        local hum = LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then pcall(function() hum:ChangeState(Enum.HumanoidStateType.Jumping) end) end
    end
end)

-- ========== Teleport ==========
local function teleportToPlayer(target)
    if not target or not target.Character then return end
    local root = target.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if myRoot then
        pcall(function() LocalPlayer.Character:MoveTo(root.Position + Vector3.new(2,0,2)) end)
    end
end

-- ========== Kill Aura ==========
spawn(function()
    while true do
        if State.KillAura and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local myRoot = LocalPlayer.Character.HumanoidRootPart
            for _, p in pairs(Players:GetPlayers()) do
                if p ~= LocalPlayer and p.Character and p.Character:FindFirstChild("Humanoid") and p.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = p.Character.HumanoidRootPart
                    local dist = (hrp.Position - myRoot.Position).Magnitude
                    if dist <= (State.KillAuraRange or 10) then
                        local hum = p.Character.Humanoid
                        pcall(function() hum.Health = 0 end)
                    end
                end
            end
        end
        wait(0.1)
    end
end)

-- ========== REFINED SAFE Aim Assist (developer-only) ==========
-- Behavior improvements requested:
--  - Smoother tracking (exponential smoothing)
--  - Persistent focus on nearest player; only switch when new target is meaningfully closer
--  - Aim continuously at head center and keep tracking while valid
--  - STILL: does NOT shoot or alter other players' health

local function getHeadPartFromCharacter(char)
    if not char then return nil end
    return char:FindFirstChild("Head") or char:FindFirstChild("UpperTorso") or char:FindFirstChild("HumanoidRootPart")
end

-- Find nearest head within range; returns head part and distance
local function findNearestHeadWithin(range)
    local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not localRoot then return nil, math.huge end
    local bestHead = nil
    local bestDist = range or math.huge
    for _,p in pairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character and p.Character.Parent then
            local head = getHeadPartFromCharacter(p.Character)
            if head and head:IsA("BasePart") then
                local dist = (head.Position - localRoot.Position).Magnitude
                if dist < bestDist then
                    bestDist = dist
                    bestHead = head
                end
            end
        end
    end
    -- include NPCs optionally
    for _,obj in pairs(Workspace:GetDescendants()) do
        if obj:IsA("Model") and obj:FindFirstChild("Humanoid") and obj ~= LocalPlayer.Character then
            local head = getHeadPartFromCharacter(obj)
            if head and head:IsA("BasePart") then
                local dist = (head.Position - localRoot.Position).Magnitude
                if dist < bestDist then
                    bestDist = dist
                    bestHead = head
                end
            end
        end
    end
    return bestHead, bestDist
end

-- Target selection/persistence logic
local currentTarget = nil
local currentTargetDist = math.huge
local TARGET_SWITCH_THRESHOLD = 0.85 -- new target must be this fraction closer to switch
local TARGET_RECHECK_INTERVAL = 0.12 -- seconds

-- Periodically update best target but with hysteresis so it doesn't flicker
spawn(function()
    while true do
        if State.AimAssist then
            local head, dist = findNearestHeadWithin(State.AimAssistRange or 80)
            if head then
                if not currentTarget then
                    currentTarget = head
                    currentTargetDist = dist
                else
                    -- If same instance, update distance
                    if head == currentTarget then
                        currentTargetDist = dist
                    else
                        -- Switch only if new head is meaningfully closer
                        if dist < (currentTargetDist * TARGET_SWITCH_THRESHOLD) then
                            currentTarget = head
                            currentTargetDist = dist
                        end
                    end
                end
            else
                currentTarget = nil
                currentTargetDist = math.huge
            end
        else
            currentTarget = nil
            currentTargetDist = math.huge
        end
        wait(TARGET_RECHECK_INTERVAL)
    end
end)

-- Exponential smoothing function to compute lerp alpha from responsiveness and dt
local function smoothingAlpha(responsiveness, dt)
    -- responsiveness ~ how quickly it moves towards the target; convert to alpha in (0,1)
    -- use 1 - exp(-k * dt) so behaviour is frame-rate independent and smooth
    local k = math.clamp(responsiveness or 8, 0.1, 50)
    return 1 - math.exp(-k * dt)
end

-- Maintain camera aiming at the currentTarget's head center
RunService.RenderStepped:Connect(function(dt)
    if not State.AimAssist then return end
    local cam = workspace.CurrentCamera
    if not cam then return end
    if currentTarget and currentTarget.Parent then
        -- verify target still valid and within range
        local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not localRoot then return end
        local dist = (currentTarget.Position - localRoot.Position).Magnitude
        if dist > (State.AimAssistRange or 80) then
            -- out of range -> drop target
            currentTarget = nil
            currentTargetDist = math.huge
            return
        end
        -- compute exact point to look at (head center). You can tweak Y offset if desired.
        local targetPos = currentTarget.Position
        -- Derive desired camera CFrame that keeps camera position but looks at targetPos
        local camPos = cam.CFrame.Position
        local desiredCFrame = CFrame.new(camPos, targetPos)
        -- Compute alpha using exponential smoothing so movement is smooth and stable
        local alpha = smoothingAlpha(State.AimAssistResponsiveness or 8, dt)
        cam.CFrame = cam.CFrame:Lerp(desiredCFrame, alpha)
    else
        -- no current target: try to find one quickly (short-circuit)
        local head, dist = findNearestHeadWithin(State.AimAssistRange or 80)
        if head then
            currentTarget = head
            currentTargetDist = dist
        end
    end
end)

-- ========== Fallback GUI ==========
local function CreateFallbackUI()
    pcall(function()
        local existing = game.CoreGui:FindFirstChild("AxtonioUI_v3")
        if existing then existing:Destroy() end
    end)

    local screen = Instance.new("ScreenGui")
    screen.Name = "AxtonioUI_v3"
    screen.ResetOnSpawn = false
    screen.Parent = game.CoreGui

    local main = Instance.new("Frame", screen)
    main.Name = "Main"
    main.Size = UDim2.new(0,720,0,580)
    main.Position = UDim2.new(0.5, -360, 0.05, 0)
    main.BackgroundColor3 = Color3.fromRGB(23,23,23)
    main.BorderSizePixel = 0
    main.Active = true
    main.Draggable = true
    main.ClipsDescendants = true

    local title = Instance.new("TextLabel", main)
    title.Size = UDim2.new(1, 0, 0, 46)
    title.Position = UDim2.new(0,0,0,0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.TextSize = 20
    title.TextColor3 = Color3.fromRGB(255,255,255)
    title.Text = "366axtonio Script | v1.0"
    title.TextStrokeTransparency = 0.8

    local scroll = Instance.new("ScrollingFrame", main)
    scroll.Size = UDim2.new(1, -20, 1, -66)
    scroll.Position = UDim2.new(0, 10, 0, 56)
    scroll.CanvasSize = UDim2.new(0,0,0,0)
    scroll.ScrollBarThickness = 8
    scroll.BackgroundTransparency = 1

    local layout = Instance.new("UIListLayout", scroll)
    layout.FillDirection = Enum.FillDirection.Vertical
    layout.SortOrder = Enum.SortOrder.LayoutOrder
    layout.Padding = UDim.new(0,10)

    local function UpdateCanvas()
        scroll.CanvasSize = UDim2.new(0,0,0,layout.AbsoluteContentSize.Y + 12)
    end
    layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(UpdateCanvas)

    -- UI Helpers
    local function NewCategory(titleText)
        local cat = Instance.new("Frame", scroll)
        cat.Size = UDim2.new(1, -12, 0, 0)
        cat.BackgroundColor3 = Color3.fromRGB(30,30,30)
        cat.BorderSizePixel = 0
        cat.AutomaticSize = Enum.AutomaticSize.Y
        cat.LayoutOrder = #scroll:GetChildren()
        local catLayout = Instance.new("UIListLayout", cat)
        catLayout.SortOrder = Enum.SortOrder.LayoutOrder
        catLayout.Padding = UDim.new(0,8)
        local header = Instance.new("TextLabel", cat)
        header.Size = UDim2.new(1,0,0,32)
        header.BackgroundColor3 = Color3.fromRGB(50,50,50)
        header.Font = Enum.Font.GothamBold
        header.TextSize = 16
        header.TextColor3 = Color3.fromRGB(245,245,245)
        header.Text = " "..titleText
        header.BorderSizePixel = 0
        return cat
    end

    local function AddButton(parent,text,cb)
        local btn = Instance.new("TextButton", parent)
        btn.Size = UDim2.new(1,-12,0,36)
        btn.BackgroundColor3 = Color3.fromRGB(90,90,90)
        btn.Font = Enum.Font.Gotham
        btn.TextSize = 15
        btn.TextColor3 = Color3.fromRGB(255,255,255)
        btn.AutoButtonColor = true
        btn.Text = text
        btn.MouseEnter:Connect(function() btn.BackgroundColor3 = Color3.fromRGB(110,110,110) end)
        btn.MouseLeave:Connect(function() btn.BackgroundColor3 = Color3.fromRGB(90,90,90) end)
        btn.MouseButton1Click:Connect(function() pcall(cb) end)
        return btn
    end

    local function AddToggle(parent,text,default,cb)
        local state = default or false
        local btn = Instance.new("TextButton", parent)
        btn.Size = UDim2.new(1,-12,0,36)
        btn.BackgroundColor3 = Color3.fromRGB(100,100,100)
        btn.Font = Enum.Font.Gotham
        btn.TextSize = 15
        btn.TextColor3 = Color3.fromRGB(255,255,255)
        btn.Text = text.." : "..(state and "On" or "Off")
        btn.AutoButtonColor = true
        btn.MouseButton1Click:Connect(function()
            state = not state
            btn.Text = text.." : "..(state and "On" or "Off")
            pcall(function() cb(state) end)
        end)
        return btn
    end

    local function AddSlider(parent,text,min,max,default,cb)
        default = default or min
        local container = Instance.new("Frame", parent)
        container.Size = UDim2.new(1,-12,0,48)
        container.BackgroundTransparency = 1
        local label = Instance.new("TextLabel", container)
        label.Size = UDim2.new(1,0,0,18)
        label.Position = UDim2.new(0,0,0,0)
        label.BackgroundTransparency = 1
        label.Font = Enum.Font.Gotham
        label.TextSize = 14
        label.TextColor3 = Color3.fromRGB(240,240,240)
        label.Text = text.." : "..tostring(default)
        local bar = Instance.new("Frame", container)
        bar.Size = UDim2.new(1,-12,0,12)
        bar.Position = UDim2.new(0,6,0,26)
        bar.BackgroundColor3 = Color3.fromRGB(80,80,80)
        bar.BorderSizePixel = 0
        local fill = Instance.new("Frame", bar)
        fill.Size = UDim2.new((default-min)/(max-min),0,1,0)
        fill.BackgroundColor3 = Color3.fromRGB(170,170,255)
        fill.BorderSizePixel = 0
        local dragging = false
        local function setFromX(x)
            local posX = x - bar.AbsolutePosition.X
            local pct = math.clamp(posX / math.max(1, bar.AbsoluteSize.X),0,1)
            local val = math.floor(min + pct * (max-min))
            fill.Size = UDim2.new(pct,0,1,0)
            label.Text = text.." : "..tostring(val)
            pcall(function() cb(val) end)
        end
        bar.InputBegan:Connect(function(inp)
            if inp.UserInputType==Enum.UserInputType.MouseButton1 then
                dragging = true
                setFromX(UserInputService:GetMouseLocation().X)
            end
        end)
        UserInputService.InputChanged:Connect(function(inp)
            if dragging and inp.UserInputType==Enum.UserInputType.MouseMovement then
                setFromX(inp.Position.X)
            end
        end)
        UserInputService.InputEnded:Connect(function(inp)
            if inp.UserInputType==Enum.UserInputType.MouseButton1 then dragging = false end
        end)
        return container
    end

    -- ========== Build categories ==========
    local playerCat = NewCategory("Player")
    AddSlider(playerCat,"WalkSpeed",16,500,State.WalkSpeed,function(v)
        State.WalkSpeed=v
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then pcall(function() hum.WalkSpeed = v * (State.SpeedBoost or 1) end) end
    end)
    AddSlider(playerCat,"JumpPower",50,500,State.JumpPower,function(v)
        State.JumpPower = v
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then pcall(function() hum.JumpPower = v end) end
    end)
    AddSlider(playerCat,"SpeedBoost",0.5,5,State.SpeedBoost,function(v)
        State.SpeedBoost=v
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then pcall(function() hum.WalkSpeed=(State.WalkSpeed or 16)*v end) end
    end)
    AddSlider(playerCat,"FlySpeed",10,300,State.FlySpeed,function(v) State.FlySpeed=v end)
    AddToggle(playerCat,"Fly (E/Q up/down + WASD)",State.Fly,function(s) enableFly(s) end)
    AddToggle(playerCat,"Infinite Jump (Space)",State.InfiniteJump,function(s) State.InfiniteJump=s end)
    AddToggle(playerCat,"Noclip",State.Noclip,function(s) State.Noclip=s end)
    AddSlider(playerCat,"Gravity",0,500,State.Gravity,function(v) State.Gravity=v Workspace.Gravity=v end)
    AddSlider(playerCat,"HipHeight",0,10,State.HipHeight,function(v)
        State.HipHeight=v
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then pcall(function() hum.HipHeight=v end) end
    end)
    AddSlider(playerCat,"FOV",50,120,State.FOV,function(v)
        State.FOV=v
        if workspace.CurrentCamera then workspace.CurrentCamera.FieldOfView=v end
    end)
    AddSlider(playerCat,"Hitbox Size",0.5,3,State.HitboxScale,function(v) State.HitboxScale=v end)
    AddButton(playerCat,"Sit",function()
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then hum.Sit=true end
    end)
    AddButton(playerCat,"Reset Character",function()
        local char = LocalPlayer.Character
        if char then char:BreakJoints() end
    end)
    AddToggle(playerCat,"FPS Booster (low gfx)",State.FPSBooster,function(s)
        State.FPSBooster=s
        if s then
            for _,obj in pairs(Workspace:GetDescendants()) do
                if obj:IsA("Part") then obj.Material=Enum.Material.SmoothPlastic obj.Reflectance=0 end
            end
        else
        end
    end)

    -- SAFE Aim Assist controls
    AddToggle(playerCat,"Aim Assist (DEV ONLY, no shooting)",State.AimAssist,function(s) State.AimAssist = s end)
    AddSlider(playerCat,"Aim Assist Range",10,300,State.AimAssistRange,function(v) State.AimAssistRange = v end)
    AddSlider(playerCat,"Aim Responsiveness (higher = snappier)",1,30,State.AimAssistResponsiveness,function(v) State.AimAssistResponsiveness = v end)

    -- ESP
    local espCat = NewCategory("ESP")
    AddToggle(espCat,"Enable ESP",State.ESP,function(s)
        State.ESP=s
        if s then for _,p in pairs(Players:GetPlayers()) do createESP(p) end else destroyAllESP() end
    end)
    AddSlider(espCat,"ESP Box Size",0.5,3,State.ESPBoxSize,function(v)
        State.ESPBoxSize=v
        for _,info in pairs(ESPMap) do
            pcall(function()
                if info.Box and info.Box.Adornee then
                    info.Box.Size = info.Box.Adornee.Size * v
                end
            end)
        end
    end)

    -- AutoFarm
    local farmCat = NewCategory("AutoFarm")
    AddToggle(farmCat,"Auto Farm",State.AutoFarm,function(s) State.AutoFarm=s end)
    AddSlider(farmCat,"Farm Delay",0.1,3,State.FarmDelay,function(v) State.FarmDelay=v end)

    -- Misc
    local miscCat = NewCategory("Misc")
    AddToggle(miscCat,"Kill Aura",State.KillAura,function(s) State.KillAura=s end)
    AddSlider(miscCat,"Kill Aura Range",1,50,State.KillAuraRange,function(v) State.KillAuraRange=v end)
    AddButton(miscCat,"Rejoin Server",function() pcall(function() TeleportService:Teleport(game.PlaceId,LocalPlayer) end) end)
    AddButton(miscCat,"ServerHop",function() pcall(function() TeleportService:Teleport(game.PlaceId,LocalPlayer) end) end)
    AddButton(miscCat,"Destroy GUI",function() pcall(function() screen:Destroy() end) end)

    -- Teleport
    local tpCat = NewCategory("Teleport")
    AddButton(tpCat,"Teleport to Random Player",function()
        local pls = Players:GetPlayers()
        if #pls <= 1 then return end
        local target
        repeat
            target = pls[math.random(1,#pls)]
        until target ~= LocalPlayer and target.Character and target.Character:FindFirstChild("HumanoidRootPart")
        
        local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if myRoot and target then
            pcall(function()
                LocalPlayer.Character:MoveTo(target.Character.HumanoidRootPart.Position + Vector3.new(2,0,2))
            end)
        end
    end)

    local listScroller = Instance.new("ScrollingFrame",tpCat)
    listScroller.Size = UDim2.new(1,-12,0,120)
    listScroller.BackgroundTransparency=1
    listScroller.ScrollBarThickness=6
    local listLayout = Instance.new("UIListLayout",listScroller)
    listLayout.SortOrder=Enum.SortOrder.LayoutOrder

    local function refreshPlayerButtons()
        for _,c in pairs(listScroller:GetChildren()) do
            if not c:IsA("UIListLayout") then pcall(function() c:Destroy() end) end
        end
        for _,p in pairs(Players:GetPlayers()) do
            if p~=LocalPlayer then
                local pb = Instance.new("TextButton",listScroller)
                pb.Size = UDim2.new(1,0,0,28)
                pb.Text = "TP -> "..p.Name
                pb.Font = Enum.Font.Gotham
                pb.TextSize = 14
                pb.TextColor3 = Color3.fromRGB(240,240,240)
                pb.BackgroundColor3 = Color3.fromRGB(80,80,80)
                pb.AutoButtonColor=true
                pb.MouseButton1Click:Connect(function() teleportToPlayer(p) end)
            end
        end
    end
    Players.PlayerAdded:Connect(refreshPlayerButtons)
    Players.PlayerRemoving:Connect(refreshPlayerButtons)
    refreshPlayerButtons()
    UpdateCanvas()
    return screen
end
-- ======== Bring / Control Players ========
local controlCat = NewCategory("Bring / Control Players")

local function bringPlayerToMe(target)
    if not target or not target.Character then return end
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
    if myRoot and targetRoot then
        pcall(function()
            targetRoot.CFrame = myRoot.CFrame + Vector3.new(2,0,2)
        end)
    end
end

local function freezePlayer(target, freeze)
    if not target or not target.Character then return end
    local hum = target.Character:FindFirstChildOfClass("Humanoid")
    if hum then
        if freeze then
            hum.WalkSpeed = 0
            hum.JumpPower = 0
            hum.PlatformStand = true
        else
            hum.WalkSpeed = 16
            hum.JumpPower = 50
            hum.PlatformStand = false
        end
    end
end

local function ragdollPlayer(target)
    if not target or not target.Character then return end
    local hum = target.Character:FindFirstChildOfClass("Humanoid")
    if hum then
        hum.PlatformStand = true
        for _, part in pairs(target.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Anchored = false
            end
        end
        -- nach 5 Sekunden automatisch wieder freigeben
        delay(5, function()
            if hum then hum.PlatformStand = false end
        end)
    end
end

-- ScrollFrame für Spieler-Buttons
local controlList = Instance.new("ScrollingFrame", controlCat)
controlList.Size = UDim2.new(1,-12,0,180)
controlList.BackgroundTransparency = 1
controlList.ScrollBarThickness = 6
local controlLayout = Instance.new("UIListLayout", controlList)
controlLayout.SortOrder = Enum.SortOrder.LayoutOrder
controlLayout.Padding = UDim.new(0,4)

-- Buttons für jeden Spieler dynamisch erstellen
local function refreshControlButtons()
    for _,c in pairs(controlList:GetChildren()) do
        if not c:IsA("UIListLayout") then pcall(function() c:Destroy() end) end
    end

    for _,p in pairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then
            -- Container für jeden Spieler
            local container = Instance.new("Frame", controlList)
            container.Size = UDim2.new(1,0,0,84)
            container.BackgroundTransparency = 1

            local nameLabel = Instance.new("TextLabel", container)
            nameLabel.Size = UDim2.new(1,0,0,20)
            nameLabel.Position = UDim2.new(0,0,0,0)
            nameLabel.Text = p.Name
            nameLabel.Font = Enum.Font.GothamBold
            nameLabel.TextSize = 14
            nameLabel.TextColor3 = Color3.fromRGB(240,240,240)
            nameLabel.BackgroundTransparency = 1

            -- Teleport To Me Button
            local tpBtn = Instance.new("TextButton", container)
            tpBtn.Size = UDim2.new(1,0,0,20)
            tpBtn.Position = UDim2.new(0,0,0,24)
            tpBtn.Text = "Teleport To Me"
            tpBtn.Font = Enum.Font.Gotham
            tpBtn.TextSize = 14
            tpBtn.TextColor3 = Color3.fromRGB(255,255,255)
            tpBtn.BackgroundColor3 = Color3.fromRGB(80,80,80)
            tpBtn.AutoButtonColor = true
            tpBtn.MouseButton1Click:Connect(function() bringPlayerToMe(p) end)

            -- Freeze Toggle Button
            local freezeBtn = Instance.new("TextButton", container)
            freezeBtn.Size = UDim2.new(1,0,0,20)
            freezeBtn.Position = UDim2.new(0,0,0,48)
            freezeBtn.Text = "Freeze"
            freezeBtn.Font = Enum.Font.Gotham
            freezeBtn.TextSize = 14
            freezeBtn.TextColor3 = Color3.fromRGB(255,255,255)
            freezeBtn.BackgroundColor3 = Color3.fromRGB(80,80,80)
            freezeBtn.AutoButtonColor = true
            freezeBtn.MouseButton1Click:Connect(function()
                local frozen = p:GetAttribute("Frozen") or false
                freezePlayer(p, not frozen)
                p:SetAttribute("Frozen", not frozen)
                freezeBtn.Text = not frozen and "Unfreeze" or "Freeze"
            end)

            -- Ragdoll Button
            local ragdollBtn = Instance.new("TextButton", container)
            ragdollBtn.Size = UDim2.new(1,0,0,20)
            ragdollBtn.Position = UDim2.new(0,0,0,72)
            ragdollBtn.Text = "Ragdoll"
            ragdollBtn.Font = Enum.Font.Gotham
            ragdollBtn.TextSize = 14
            ragdollBtn.TextColor3 = Color3.fromRGB(255,255,255)
            ragdollBtn.BackgroundColor3 = Color3.fromRGB(80,80,80)
            ragdollBtn.AutoButtonColor = true
            ragdollBtn.MouseButton1Click:Connect(function() ragdollPlayer(p) end)
        end
    end
end

Players.PlayerAdded:Connect(refreshControlButtons)
Players.PlayerRemoving:Connect(refreshControlButtons)
refreshControlButtons()

-- ========== Run GUI ==========
if OrionLib and type(OrionLib.MakeWindow)=="function" then
    CreateFallbackUI() -- single-page consistency
else
    CreateFallbackUI()
end

-- Apply initial defaults
spawn(function()
    wait(0.5)
    local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if hum then
        pcall(function() hum.WalkSpeed=State.WalkSpeed end)
        pcall(function() hum.JumpPower=State.JumpPower end)
        hum.HipHeight = State.HipHeight
    end
    if workspace.CurrentCamera then workspace.CurrentCamera.FieldOfView=State.FOV end
    Workspace.Gravity = State.Gravity
end)
